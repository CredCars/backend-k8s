name: Deploy Backend to EKS

on:
  push:
    branches:
      - staging
      - main

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  ECR_BACKEND: ${{ vars.ECR_BACKEND }}
  EKS_CLUSTER: ${{ vars.EKS_CLUSTER }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ vars.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push multi-arch Docker image
        id: build-image
        run: |
          IMAGE_TAG=${GITHUB_SHA::8}
          REPO_URI=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_BACKEND }}

          # Set up Docker Buildx
          docker buildx create --use --name mybuilder || true
          docker buildx inspect --bootstrap

          # Build multi-arch image and push to ECR
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            -t ${REPO_URI}:${IMAGE_TAG} \
            --push .

          echo "image=${REPO_URI}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
          kubectl get nodes

      - name: Determine namespace and environment
        id: ns
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            echo "namespace=production" >> $GITHUB_OUTPUT
            echo "env=production" >> $GITHUB_OUTPUT
          else
            echo "namespace=staging" >> $GITHUB_OUTPUT
            echo "env=staging" >> $GITHUB_OUTPUT
          fi

      # ----------------------------
      # üîê Apply Secrets and ConfigMap
      # ----------------------------
      - name: Apply environment-specific secrets and configmap
        run: |
          NAMESPACE=${{ steps.ns.outputs.namespace }}
          ENV=${{ steps.ns.outputs.env }}

          if [ "$ENV" = "production" ]; then
            MONGODB_URI=${{ vars.MONGODB_URI_PROD }}
            JWT_SECRET=${{ vars.JWT_SECRET }}
            JWT_REFRESH_SECRET=${{ vars.JWT_REFRESH_SECRET }}
            PORT=${{ vars.PORT }}
            NODE_ENV="production"
            ALLOWED_ORIGINS="${{ vars.ALLOWED_ORIGINS_PROD }}"
            FRONTEND_URL="${{ vars.FRONTEND_URL_PROD }}"
          else
            MONGODB_URI=${{ vars.MONGODB_URI_STAGING }}
            JWT_SECRET=${{ vars.JWT_SECRET }}
            JWT_REFRESH_SECRET=${{ vars.JWT_REFRESH_SECRET }}
            PORT=${{ vars.PORT }}
            NODE_ENV="staging"
            ALLOWED_ORIGINS="${{ vars.ALLOWED_ORIGINS_STAGING }}"
            FRONTEND_URL="${{ vars.FRONTEND_URL_STAGING }}"
          fi

          # Create Secret manifest
          cat <<EOF > secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: credcars-backend-secrets
            namespace: ${NAMESPACE}
          type: Opaque
          stringData:
            MONGODB_URI: "${MONGODB_URI}"
            JWT_SECRET: "${JWT_SECRET}"
            JWT_REFRESH_SECRET: "${JWT_REFRESH_SECRET}"
          EOF

          # Create ConfigMap manifest
          cat <<EOF > configmap.yaml
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: credcars-backend-config
            namespace: ${NAMESPACE}
          data:
            PORT: "${PORT}"
            NODE_ENV: "${NODE_ENV}"
            ALLOWED_ORIGINS: "${ALLOWED_ORIGINS}"
            FRONTEND_URL: "${FRONTEND_URL}"
          EOF

          # Apply both
          kubectl apply -f secret.yaml
          kubectl apply -f configmap.yaml

      - name: Apply Kubernetes manifests
        run: |
          NAMESPACE=${{ steps.ns.outputs.namespace }}
          kubectl apply -f k8s/namespaces.yaml
          for file in k8s/deployment.yaml k8s/service.yaml k8s/ingress.yaml; do
            echo "Applying $file to namespace $NAMESPACE"
            sed "s/namespace: staging/namespace: ${NAMESPACE}/g" "$file" | kubectl apply -f -
          done

      - name: Update Deployment image
        run: |
          NAMESPACE=${{ steps.ns.outputs.namespace }}
          kubectl -n $NAMESPACE set image deployment/credcars-backend credcars-backend=${{ steps.build-image.outputs.image }}
      
      - name: Force rollout if secret/config changed
        run: |
          NAMESPACE=${{ steps.ns.outputs.namespace }}
          kubectl -n $NAMESPACE patch deployment credcars-backend \
            -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"secret-last-updated\":\"$(date +%s)\",\"configmap-last-updated\":\"$(date +%s)\"}}}}}"

      - name: Wait for rollout
        run: |
          NAMESPACE=${{ steps.ns.outputs.namespace }}
          kubectl -n $NAMESPACE rollout status deployment/credcars-backend --timeout=5m
